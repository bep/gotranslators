//go:generate go run main.go

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/ast"
	"go/token"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	_ "github.com/go-playground/locales"
	_ "github.com/go-playground/locales/currency"
	"golang.org/x/tools/go/packages"
)

const header = `
// This file is autogenerated.

package translators

`

func main() {
	createTranslatorsMap()
	createCurrenciesMap()
}

func createTranslatorsMap() {
	const localeMod = "github.com/go-playground/locales"
	b := &bytes.Buffer{}
	cmd := exec.Command("go", "list", "-m", "-json", localeMod)
	cmd.Stdout = b

	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}

	m := make(map[string]interface{})

	if err := json.Unmarshal(b.Bytes(), &m); err != nil {
		log.Fatal(err)
	}

	dir := m["Dir"].(string)

	var packages []string

	filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if !d.IsDir() || d.Name() == "currency" {
			return nil
		}

		name := filepath.Base(path)

		if _, err := os.Stat(filepath.Join(path, fmt.Sprintf("%s.go", name))); err == nil {
			packages = append(packages, name)
		}

		return nil
	})

	sort.Strings(packages)

	f, err := os.Create(filepath.Join("../translators.autogen.go"))
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	fmt.Fprintf(f, "%s\nimport(\n\"github.com/go-playground/locales\"\n", header)

	for _, imp := range packages {
		fmt.Fprintf(f, "\"%s/%s\"\n", localeMod, imp)
	}

	fmt.Fprintln(f, "\n)\n\nfunc init() {")

	for _, imp := range packages {
		fmt.Fprintf(f, "translatorFuncs[%q] = func() locales.Translator { return %s.New() }\n", strings.ToLower(imp), imp)
	}

	fmt.Fprintln(f, "\n}")
}

func createCurrenciesMap() {
	cfg := &packages.Config{
		Mode:  packages.LoadSyntax,
		Tests: false,
	}

	pkgs, err := packages.Load(cfg, "github.com/go-playground/locales/currency")
	if err != nil {
		log.Fatal(err)
	}

	pkg := pkgs[0]

	collector := &currencyCollector{}

	for _, f := range pkg.Syntax {
		ast.Inspect(f, collector.handleNode)
	}

	sort.Strings(collector.constants)

	f, err := os.Create(filepath.Join("../currencies.autogen.go"))
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	fmt.Fprintf(f, "%s\nimport \"github.com/go-playground/locales/currency\"\n", header)

	fmt.Fprintf(f, "var currencies = map[string]currency.Type {")
	for _, currency := range collector.constants {
		fmt.Fprintf(f, "\n%q: currency.%s,", currency, currency)
	}
	fmt.Fprintln(f, "}")

}

type currencyCollector struct {
	constants []string
}

func (c *currencyCollector) handleNode(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.CONST {
		return true
	}
	typ := ""
	for _, spec := range decl.Specs {
		vspec := spec.(*ast.ValueSpec)
		if vspec.Type == nil && len(vspec.Values) > 0 {
			typ = ""

			ce, ok := vspec.Values[0].(*ast.CallExpr)
			if !ok {
				continue
			}
			id, ok := ce.Fun.(*ast.Ident)
			if !ok {
				continue
			}
			typ = id.Name
		}
		if vspec.Type != nil {
			ident, ok := vspec.Type.(*ast.Ident)
			if !ok {
				continue
			}
			typ = ident.Name
		}
		if typ != "Type" {
			// This is not the type we're looking for.
			continue
		}
		// We now have a list of names (from one line of source code) all being
		// declared with the desired type.
		// Grab their names and actual values and store them in f.values.
		for _, name := range vspec.Names {
			c.constants = append(c.constants, name.String())
		}
	}
	return false
}
